<image src="img\gitandgithub logo.png" alt="Logo">

# Работа с Git и Github

## 1. Проверка наличий установленного Git

В терминале выполнить команду:

```
git --version
```

Если Git установлен, появится сообщение с версией Git иначе будет сообщение об ошибке.

## 2. Установка Git

Загружаем последнию версию с сайта
https://git-scm.com/downloads.  
Устанавливаем с настройками по умолчанию.

## 3. Настройка Git

При первом использовании Git необходимо представиться. Для этого нужно ввести в терминале две команды:

```
git config --global user.name «Ваше имя английскими буквами»
git config --global user.email ваша почта@example.com
```

## 4. Инициализация репозитория

В терминале выполнить команду:

```
 git init
```

В папке создается скрытая папка `.git`.

## 5. Отслеживание изменений в файлах

После создания файлов в каталоге Git необходимо добавить их в индекс для того что бы Git смог отслеживать изменения в файлах и папках каталога.  
Что бы узнать какие файлы добавлены в индекс нужно выполнить команду:

```
git status
```

После ввода команды в консоли отобразятся красным цветом файлы и папки которые не добавлены в индекс или зеленым цветов если они там есть.  
Для фиксации файлов выполните команду:

```
 git add <имена папок или файлов>.
```

Для фиксации всех файлов можно выполнить команду:

```
git add .
```

## 6. Фиксация (Сохранение) изменений в файлах

Для того что бы сохранить изменение в файлах выполните команду - `git commit` + дополнительные флаги: `-a` (сокращение команды `add`) , `-m ""`(Флаг сообщения).

1. вариант команды:

```
git commit -a -m "new folder"
```

2. вариант команды:

```
git commit -am "new folder"
```

## 7. Журнал изменений

Для просмотра журнала изминений выполните команду:

```
git log
```

Показывает полное описание в журнале

<image src="img/gitlog.png" alt="git log">

Так же журнал можно отобразить в упращенном виде при помощм дполнительного флага:

```
git log --oneline
```

<image src="img/gitlogoneline.png" alt="oneline">

Что бы выйти из журнала в консоли нужно нажать клавишу - `Q` .

Для графического отображение веток в журнале выполните команду:

```
git log --graph
```

## 8. Переключение между версиями файла

**Старые версии Git.**

1. вариант - Выполните команду:

```
git checkout <хэш-код коммита>
```

Вернуться к актуальному состоянию и продолжить работу:

```
git checkout master
```

**Новые версии Git.**

2. вариант - Выполните команду:

```
git switch + <хэш-код коммита>
```

Вернуться к актуальному состоянию и продолжить работу:

```
git switch -
```

## 9. Просмотр разницы между файлом и закоммиченным файлом

Выполните команду:

```
git diff
```

<image src="img/gitdiff.png" alt="gitdiff">

Часто бывает необходимость увидеть, какие изменения какими
пользователями и в рамках каких коммитов вносились в тот или иной файл. Это
можно сделать, выполнив команду `“git blame”` и указав имя интересующего нас
файла:

```
git blame index.html
```
Эта команда выведет строки файла и напротив каждой строки укажет и
коммиты, и время внесения изменений, и имена пользователей, которые их
вносили. Вот фрагмент вывода этой команды:

<image src="img/3.jpg" alt="gitdiff">

## 10. Ветки в Git

По умолчанию имя основной ветки в Git - **master** .

Что бы узнать какие ветки есть в репозитории выполните команду:

```
git branch
```

`*` - указывает на какой ветке мы находимся .

Для создание новой ветки выполните команду:

```
git branch <имя ветки>
```

Для создание новой ветки и сразу перехода на нее выполните команду:

**Старая версия Git**

1. вариант:

```
git checkout -b <имя ветки>
```

**Новая версия Git**

2. вариант:

```
git switch -c + <имя ветки>
```

Для перехода на другую ветку выполните команду:

**Старая версия Git**

1. вариант:

```
git checkout <имя ветки>
```

**Новая версия Git**

2. вариант:

```
git switch <имя ветки>
```

Для возврата в основную ветку выполните команду:

**Новая версия Git**

```
git switch -
```

**Старая версия Git**

```
git checkout master
```

Чтобы добавить изменение из другой ветки:

1. Перейдите в основную ветку с помощью команды:

**Новая версия Git**

```
git switch -
```

**Старая версия Git**

```
git checkout master
```

2. Выполните команду:

```
git merge <имя ветки>
```

Для удаление ветки выполните команду:

```
git branch -d <имя ветки>
```

Ограничение по удалению веток в Git:

1. Нельзя удалить ветку если вы вней находитесь .
2. Нельзя удалить не слитую ветку но вы можете сделать это принудительно с помощью команды:

```
git branch -D <имя ветки>
```

## 11. Конфликты слияния веток в Git

Конфликты возникают, когда два человека изменяют одни и те же строки в файле или один разработчик удаляет файл, который в это время изменяет другой разработчик. В таких случаях Git не может автоматически определить, какое изменение является правильным. Конфликты затрагивают только того разработчика, который выполняет слияние, остальная часть команды о конфликте не знает. Git помечает файл как конфликтующий и останавливает процесс слияния.

**Пример:**

<image src="img/git conflict.png" alt="gitdiff">

Самый простой способ разрешить конфликт — отредактировать конфликтующий файл или выбрать вариант как показан на картинке.

**После разрешения конфликта обязательно нужно сделать коммит!**

## 12. Файл gitignore (Файлы исключение которые не нужно добавлять в Git)

Для исключения файлов из системы Git необходимо:

1. Создать файл в репозитории - `.gitignore` .
2. Добавить в созданный файл имена , расширение файлов или папок, а так же шаблоны, которые не нужно отслеживать с помощью Git.

## 13. Работа с удаленными репозиториями (Github)

Для удаленной работы с репозиториями необходимо:

1. Пройти регистрацию на сайте [Github](https://github.com) .
2. Создать локальный репозиторий .
3. Создать удаленный репозиторий .
4. Свзять локальный репозиторий с удаленным .

Команды для работы с удаленным репозиторием:

1. Связывает удаленный репозиторий с локальным:

```
git remote add origin git@github.com:Artoym715/Test-1.git
```

`origin` - псевдоним удаленного репозитория  
`git@github.com:Artoym715/Test-1.git` - url адрес репозитория в сети

2. Переименовать ветку **master** в **main**:

```
git branch -M main
```

3. Отправить файлы в удаленный репозиторий:

```
git push -u origin main
```

4. Получить изменения с удаленного репозитория в локальный:

```
git pull
```

Это составная команда - получает данные и сливает их с локальной веткой

С помощью команды `git remote` мы также просматривали информацию об
этом удалённом репозитории, добавив после неё команду `show` и имя `origin`:
```
git remote show origin
```
Команда, с помощью которой вы можете вывести информацию о
путях к вашим удалённым репозиториям:
```
git remote -v
```
Вывод этой команды обычно выглядит следующим образом:

<image src="img/2.jpg" alt="gitremote-v">

При необходимости вы можете заменить репозиторий origin. Например,
поменять путь к этому репозиторию. Для этого сначала нужно удалить текущий
репозиторий:
```
git remote remove origin
```
И затем снова добавить новый удалённый репозиторий:
```
git remote add origin path
```
Вы также можете поменять путь к этому репозиторию, если захотите:
```
git remote set-url origin new-path
```
Кроме того, вы можете поменять пути для каждой из операций — fetch и
push — отдельно. Например, для операции push команда изменения пути будет
такой:
```
git remote set-url --push origin new-path
```
Система контроля версий Git также позволяет добавить к своему
локальному репозиторию несколько удалённых.

Вначале добавим к нашему репозиторию ещё
один удалённый:
```
git remote add vendor vendor-repo-path
```
После такого действия вы сможете отправлять изменения из своего
локального репозитория в какой-то один удалённый репозиторий или сразу в
оба. Для отправки изменений в каждый репозиторий отдельно вам нужно просто
выполнить последовательно две команды:
```
git push -u origin master
git push -u vendor master
```
При этом затянуть изменения из всех репозиториев в свой локальный
можно одной командой. Но это можно сделать только без слияния, потому что
возможны конфликты не только кода из удалённого репозитория и кодом из
локального, но и кодов из двух удалённых репозиториев между собой:
```
git fetch --all
```
После такого действия вы сможете просматривать затянутые изменения и
сравнивать удалённые ветки с ветками своего локального репозитория:
```
git log origin/master ^master
git log vendor/master ^master
```
При необходимости вы можете также вливать нужные вам изменения
командной `git merge`, например:
```
git merge origin/master
или
git merge vendor/master
```
Способ, который позволяет сделать так, чтобы
однократный `“git push”` отправлял изменения сразу в несколько репозиториев.

Для этого нужно придумать название некого виртуального репозитория,
который будет в себе содержать пути ко всем удалённым. Пусть он называется
`“all”`. Давайте добавим его тоже с таким же путём, как путь к нашему первому
репозиторию:
```
git remote add all path-1
```
Дальше вы можете добавить к этому репозиторию пути:
```
git remote set-url --add --push all path-1
git remote set-url --add --push all path-2
```
И теперь вы можете отправлять наши изменения сразу во все репозитории,
используя имя `all`:
```
git push all master
```

## 14. Pull request (Github)

1. Найти интересующий вас репозиторий в поиске на [Github](https://github.com) .
2. Нажимаем на кнопку - `Code` и копируем ссылку на репозиторий .
3. Выполняем команду:

```
git clone <адрес репозитория> <имя папки для репозитория>
```

Для предложение изминений в чужой репозиторий (`pull request`) необходимо:

1. Скопировать репозиторий себе в аккаунт на Github с помощью кнопки - `Fork` .
2. Нажимаем на кнопку - `Code` и копируем ссылку на репозиторий .
3. Выполняем команду:

```
git clone <адрес репозитория> <имя папки для репозитория>
```

4. Создаем новую ветку и переключаемся на нее.
5. Вносим изменение и фиксируем изменение.
6. Выполняем команду:

```
git push -u origin <имя ветки>
```

7. На сайте Github нажимаем на кнопку - `pull request` .

## 15. Синхронизация в ветках Git

```
git remote show origin
```
Эта команда позволяет просмотреть, какие локальные ветки связаны с
ветками удалённого репозитория и каков их статус. Эта команда выводит
информацию в следующем формате:

<image src="img/1.jpg" alt="gitremote">

В начале этого вывода написано `“* remote origin”`, что указывает на то, что
эта информация относится к состоянию локального репозитория относительно
удалённого репозитория `origin`. Далее указаны пути к этому репозиторию для
операций `fetch` и `push` и то, что основная ветка — `master`.

Затем идёт блок информации о состоянии веток. Вначале перечислены
удалённые ветки и информация о том, что они отслеживаются локальными
ветками (в примере выше — пометка `“tracked”`).

И в конце блока идёт конфигурация локальных веток для команды `git push`.
Здесь отображается информация о том, в какие удалённые ветки будет
отправляться информация из локальных и каков статус локальных веток. Статус
`“up to date”` говорит о том, что локальная и удалённая ветки синхронизированы.
Статус `“fast-forwardable”` сообщает нам о том, что в локальной ветке произошли
изменения и мы их можем отправить в удалённую ветку.

Здесь также может быть статус `“local out of date”`, который говорит о том,
что локальная ветка отстаёт от удалённой: в удалённом репозитории в этой ветке
произошли какие-то изменения, которых ещё нет локально.

Вы можете скачать все изменения из ветки удалённого репозитория в
локальный, но без обновления самой ветки обновлять не будем. Это делается при
помощи команды:

```
git fetch
```
После её выполнения вы можете посмотреть, какие изменения были
внесены в удалённую ветку, для этого можно воспользоваться командой `git log`, в
параметрах которой указав имена удалённой и локальной веток:

```
git log origin/1-issue ^1-issue
```
Такой вариант команды выведет те коммиты, которые отличают удалённую
ветку от локальной. Содержимое каждого такого коммита вы можете
просмотреть командой:

```
git diff hash
```
В данном случае, `hash` — это хэш коммита. Если вы захотите влить
удалённую ветку в свою локальную, вы можете выполнить уже известную вам
команду:

```
git pull
```
Эту команду также можно выполнять для отдельных веток, указав имя
удалённого репозитория и название нужной ветки:

```
git pull origin 1-issue
```
Таким образом, команда `git pull` затягивает изменения из удалённого
репозитория и сливает их с изменениями в локальном репозитории, в то время
как команда `git fetch` их просто затягивает, но слияния не производит.

## 16. Отмена несохранённых изменений

Чтобы вернуть файл к исходному состоянию,
нужно выполнить команду:

```
git restore index.html
```
Её выполнение приведёт к тому, что сделанные в этом файле изменения
исчезнут. Если же файл уже был добавлен в индекс, то его можно вернуть из
индекса аналогичной командой, но с параметром `“--staged”`:
```
git restore --staged styles.css
```
Если же вы изменили в проекте сразу множество файлов и решили удалить
все эти изменения, то вызывать команду `“git restore”` для каждого файла будет
уже не так удобно, и вы можете воспользоваться командой:
```
git reset --hard
```
Эта команда - удаления всех незакоммиченных изменений. В том числе, кстати, тех
изменений, которые были добавлены в индекс.

При этом команда `“git reset”` не удаляет те файлы, которые не
отслеживаются и ещё ни разу не добавлялись в индекс — файлы, которые
находятся в состоянии `“untracked”`. Для того, чтобы их удалить, можно
воспользоваться командой:
```
git clean -f
```
Чтобы Git перестал отслеживать изменения в файле, его
нужно удалить из отслеживания командой:
```
git rm --cached file_name
```
В этой команде параметр “rm” расшифровывается как “remove”, то есть
по-английски “удалить”, а “cached” означает, что нужно не удалить файл из
рабочего каталога, а только перестать его отслеживать.

## 17. Отмена сохранённых изменений

Если вам нужно вернуть файл к конкретной версии на
момент определённого коммита, вы можете выполнить уже знакомую нам
команду “git checkout”, но указать не имя ветки, как раньше, а имя коммита и имя
этого файла, например:
```
git checkout b45a983 index.html
```
И этот файл будет возвращён к нужной версии и сразу добавлен в индекс.
Вы можете закоммитить эти изменения — то есть зафиксировать эту версию
файла, а можете их пока отменить: либо командой `“git reset --hard”`, которая
может быть полезна сразу для нескольких файлов, либо обычно предлагаемой в
таких случаях Git’ом командой:
```
git restore --staged index.html
```
Она переведёт изменения из индекса в изменённое состояние. после чего
удалить эти изменения совсем можно командой:
```
git restore index.html
```
### Отмена комита целиком
Если же вы хотите отменить коммит целиком, вы можете воспользоваться
командой `“git revert”`. С помощью неё вы можете отменить как последний коммит,
так и любой предыдущий. Пример выполнения команды:
```
git revert b45a983
```
При этом указывать нужно коммит к состоянию которого нам нужно
вернуть ветку, а не тот, который нужно отменить. После выполнения этой
команды вам, возможно, будет предложено отредактировать сообщение
коммита, после чего для сохранения этого сообщения и выхода из редактора `vim`
вы можете выполнить команду:
```
:wq
```
Обратите внимание, что `“git revert”` осуществляет отмену конкретного
коммита, то есть все последующие коммиты будут отменены. Если вам нужно
отменить несколько коммитов, то это можно сделать последовательным
выполнением команды `“git revert”`:
```
git revert --no-commit hash3
git revert --no-commit hash2
git revert --no-commit hash1
```
Если указывать при этом параметр `“--no-commit”`, вы сможете откатиться
на несколько версий назад, не делая множество коммитов, а сделав
единственный коммит в конце.
### Отмена или сброс самих коммитов
Отмену или сброс самих коммитов можно делать командой `“git reset”`, у которой есть три
основных режима работы — мягкий, жёсткий и смешанный — `soft`, `hard` и `mixed`.

Для того, чтобы разобраться с командой `“git reset”`, нам нужно
познакомиться с важным понятием — понятием указателя `HEAD`. `“Head”` в
переводе с английского означает `“голова”`. Представьте, что у вас есть ветка с
коммитами, и `HEAD` — это указатель на последний коммит текущей ветки. То есть
если мы ветку переключим на другую, то этот указатель будет указывать уже на
её последний коммит:

<image src="img/4.jpg" alt="git reset">

Если мы выполним команду `“git reset”` в `“мягком варианте”` и укажем в
качестве параметра предпоследний коммит:
```
git reset --soft C
```
то мы сбросим изменения последнего коммита и отправим их в индекс:

<image src="img/5.jpg" alt="git reset">

То есть если вы после этого снова сделаете коммит, то этот коммит будет
полностью аналогичен коммиту `“D”`, который вы сбросили.

И если мы выполним команду `“git reset”` в смешанном варианте — с
параметром `“--mixed”`:
```
git reset --mixed C
```
то мы снова сбросим изменения до указанного коммита, но только всё,
что было сброшено, будет сохранено в виде незакоммиченных и недобавленных
в индекс изменений в рабочей директории:

<image src="img/6.jpg" alt="git reset">

Кстати, `“mixed”` — это вариант команды `“git reset”` по умолчанию, поэтому
его можно не указывать, и это будет сброс именно по смешанному варианту:
```
git reset C
```
Такой сброс приведёт к тому, что последующие коммиты
будут отменены, а все изменения, которые в них содержались, вернутся в
рабочий каталог, и они не будут добавлены в индекс. Чтобы сделать коммит,
идентичный последнему, нам нужно сначала, как обычно добавить всё в индекс,
а затем закоммитить:
```
git add .
git commit -m 'changes'
```
Последний вариант сброса коммитов, который мы разберём — жёсткий. С
ним вы уже знакомы из предыдущих тем, но мы выполняли эту команду без
параметров и, по сути, сбрасывали изменения до последнего коммита, не
отменяя сам коммит.

Если вы выполните жёсткий вариант команды `“git reset”`, с параметром `“--hard”`, и укажете конкретный коммит:

```
git reset --hard C
```
то изменения в последующих коммитах просто будут безвозвратно удалены:

<image src="img/7.jpg" alt="git reset">

Обратите особое внимание на то, что коммиты будут удалены
безвозвратно, поэтому использовать этот, самый `“зверский”`, вариант команды
`“git reset”` следует крайне осторожно и только тогда, когда вы точно уверены в
своих действиях.

### Изменении последнего коммита

Такая необходимость тоже часто возникает на практике.
Например, если вы вдруг поняли, что написали сообщение последнего коммита с
ошибкой, вы можете выполнить команду:
```
git commit --amend -m 'new comment'
```
И сообщение коммита изменится на новое `“new commet”`. Либо если вы
вдруг поняли, что забыли добавить какой-то файл в последний коммит, вам после
его изменения нужно его просто добавить в индекс:
```
git add .
```
...а затем добавить в последний коммит аналогичной командой:
```
git commit --amend --no-edit
```
Параметр `“no-edit”` означает, что вы не хотите редактировать сообщение коммита.

## 18. Отмена слияния веток

Это отдельный тип изменений. Чтобы отменить такое слияние, вы можете
выполнить специально предназначенную для этого команду:
```
git reset --merge hash
```
При этом нужно указать коммит, до которого вам нужно откатиться. В
данном случае – коммит, предшествующий коммиту со слиянием, в котором был
зафиксирован `“merge”`.

В случае, если вы выполнили команду `“git merge”`, но слияние не
произошло из-за конфликтов, вы также можете его отменить, но уже при помощи
другой команды:
```
git merge --abort
```
Она отменит все незакоммиченные изменения, произошедшие в рабочем
каталоге в результате неудачного слияния.

## 19. Откладывание изменений

Система контроля версий Git позволяет откладывать незакоммиченные
изменения.

Чтобы изменения отложить, вам нужно просто выполнить команду:
```
git stash
```
Если после выполнения этой команды вы посмотрите статус рабочей
директории, то в ней не будет никаких незакоммиченных изменений, а её
состоянии будет соответствовать последнему коммиту. 

После этого вы сможете перейти к выполнению другой задачи и, когда её закоммитите, сможете вернуть
более ранние изменения из отложенных командой:
```
git stash pop
```
При этом отложенные изменения будут слиты с теми, которые вы только что закоммитили. Возможно, что это произойдёт автоматически, и тогда вы увидите просто сообщение со словом `“auto-merging”`, либо же произойдёт конфликт слияния, который вам придётся разрешать вручную аналогично любому другому конфликту слияния, что вы уже умеете делать.

Команда `“git stash”` позволяет откладывать несколько порций изменений.
Вы можете внести изменения, отложить их с помощью `“git stash”`, потом внести
новые изменения, и снова отложить их с помощью `“git stash”`, и они будут
сохранены отдельно. 

Теперь, если вы будете выполнить команду `“git stash pop”`,
вы будете возвращать изменения в обратном порядке: сначала те, которые были
добавлены самой последней командой `“git stash”`, затем — предпоследней, и так
далее.

При необходимости вы также можете отменить последнюю порцию отложенных изменений командой:
```
git stash drop
```
Вы также можете выполнять эту команду несколько раз, чтобы последовательно отменить все порции изменений, отложенных
последовательным выполнением команды `“git stash”`.

## 20. Перемещение изменений

Набор изменений, то есть сделанных коммитов, вы также при необходимости можете переместить между ветками.

Представьте, что у вас есть две ветки — `dev` и `master`. Сначала была создана
ветка dev, потом от неё возникла ветка master, которая развивалась как-то
отдельно:

<image src="img/8.jpg" alt="git merge">

И тут решили, что пора бы накопившиеся в ветке dev изменения отправить
в ветку master. 

Это можно сделать при помощи слияния — команды `“git merge”`. 

В результате её выполнения у вас в ветке master возникнет новый коммит,
содержащий все изменения из ветки `dev`, которых ещё не было в ветке `master`:

<image src="img/9.jpg" alt="git merge">

Напомним, что в данном случае эту команду нужно выполнять в ветке
`“master”`, в которую вы вливаете ветку `“dev”`:
```
git merge dev
```
В примере на изображении выше коммиты, обозначенные буквами `C` и `D`,
попадут в единый коммит `G` в ветке `master`.


И в случае удаления ветки `dev` восстановить историю этих двух коммитов уже не получится. 

Эта особенность считается одним из минусов механизма слияния. 

И, если вам нужно сохранить историю коммитов — перенести её целиком в другую ветку, существует
специальный механизм, который называется `rebase`.

Команда при этом будет выглядеть так:
```
git rebase dev
```
если мы выполним `rebase`, мы изменим родительский коммит нашей ветки. По сути, мы перебазируем нашу ветку на ветку `master` :

<image src="img/10.jpg" alt="git rebase">

Поскольку мы переносим эти изменения после изменений в ветке `master`, то это будут уже немного другие коммиты, которые в себе будут содержать изменения перенесённых коммитов, наложенные на изменения из ветки `master`.

И, разумеется, хэши этих коммитов тоже будут другие. Но каждый из них будет содержать в себе изменения из соответствующих перенесённых коммитов.

Преимущество этого способа заключается в том, что история изменений остаётся прямой и удобной для просмотра и анализа, но при этом есть и `недостаток` : в будущем по такой истории будет достаточно сложно понять, что
произошёл именно `git rebase`.

Третий механизм, который важно знать, это `cherry-pick`.

Этот механизм позволяет перенести какой-то один или несколько коммитов из одной ветки в
другую без переноса других изменений.

Вы хотите только перенести изменения из этого коммита, — коммита `D`, — в ветку master без
предыдущей истории. Это как раз делается при помощи операции `cherry-pick` :
```
git cherry-pick D
```
Ветка, в которую вы переносите нужный вам коммит, будет содержать все изменения из коммита `D`, но не будет содержать изменения из коммита `C` :

<image src="img/11.jpg" alt="git cherry-pick">

## 21. Работа в команде

Существует 2 наиболее распостраненные моодели ветвления в Git `git flow` и `trunk-based`.

### Модель git flow

<image src="img/12.jpg" alt="git-flow">

### Модель trunk-based development (TBD)

<image src="img/13.png" alt="TBD">
